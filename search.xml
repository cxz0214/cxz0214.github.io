<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络——第一章(概述)</title>
      <link href="/2022/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><ol><li>计算机网络已有一种通信基础设施发展成为一种重要的<strong>信息服务基础设施</strong>.</li><li>计算机网络已经像水、电、煤气这些基础设施一样，成为我们<strong>生活中不可或缺的一部分</strong>.</li></ol><h2 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h2><h3 id="1-2-1-网络、互联网-互联网-和因特网"><a href="#1-2-1-网络、互联网-互联网-和因特网" class="headerlink" title="1.2.1 网络、互联网(互联网)和因特网"></a>1.2.1 网络、互联网(互联网)和因特网</h3><ol><li>网络(Network)由若干<strong>结点</strong>(Node)和连接这些结点的<strong>链路</strong>(Link)组成.</li><li>多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网(或互连网).因此，互联网是”<strong>网络的网络(Network of Networks)</strong>“.</li><li><strong>因特网(Internet)</strong>是世界上最大的互联网络(用户数以亿计，互连的网络数以百万计).</li></ol><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115164030417.png" alt="internet与Internet的区别"></p><h3 id="1-2-2-因特网发展的三个阶段"><a href="#1-2-2-因特网发展的三个阶段" class="headerlink" title="1.2.2 因特网发展的三个阶段"></a>1.2.2 因特网发展的三个阶段</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115164419212.png" alt="因特网发展的三个阶段"></p><h3 id="1-2-3-因特网标准化工作"><a href="#1-2-3-因特网标准化工作" class="headerlink" title="1.2.3 因特网标准化工作"></a>1.2.3 因特网标准化工作</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115164933856.png" alt="因特网标准化工作"></p><h3 id="1-2-4-因特网的组成"><a href="#1-2-4-因特网的组成" class="headerlink" title="1.2.4 因特网的组成"></a>1.2.4 因特网的组成</h3><ol><li><strong>边缘部分</strong>：由所有连接在因特网上的<strong>主机</strong>组成.这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>(传送数据、音频或视频)和<strong>资源共享</strong>.</li><li><strong>核心部分</strong>：由<strong>大量网络</strong>和连接这些网络的路由器组成.这部分是为边缘部分提供服务的(提供连通性和交换).</li></ol><h2 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h2><h3 id="1-3-1-电路交换-Circuit-Switching"><a href="#1-3-1-电路交换-Circuit-Switching" class="headerlink" title="1.3.1 电路交换(Circuit Switching)"></a>1.3.1 电路交换(Circuit Switching)</h3><ul><li>电话交换机接通电话线的方式成为<strong>电路交换</strong>.</li><li>从通信资源的分配角度来看，交换就是按照某种方式动态的分配传输线路的资源.</li><li>电路交换的三个步骤：<ol><li>建立连接(分配通信资源)</li><li>通话(一直占用通信资源)</li><li>释放连接(归还通信资源)</li></ol></li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115170305447.png" alt="电话通话示意图"></p><h3 id="1-3-2-分组交换-Packet-Switching"><a href="#1-3-2-分组交换-Packet-Switching" class="headerlink" title="1.3.2 分组交换(Packet Switching)"></a>1.3.2 分组交换(Packet Switching)</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115170832195.png" alt="分组交换示意图"></p><h3 id="1-3-3-报文交换"><a href="#1-3-3-报文交换" class="headerlink" title="1.3.3 报文交换"></a>1.3.3 报文交换</h3><p>​    报文交换中的交换结点也采用<strong>存储转发方式</strong>，但报文交换对报文的大小没哟限制，要求交换结点有较大的缓存空间.报文交换用于早期的电报通信网，现在<strong>较少使用</strong>，通常被较为先进的分组交换方式所取代.</p><h3 id="1-3-4-电路交换、报文交换、分组交换的对比"><a href="#1-3-4-电路交换、报文交换、分组交换的对比" class="headerlink" title="1.3.4 电路交换、报文交换、分组交换的对比"></a>1.3.4 电路交换、报文交换、分组交换的对比</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221115171704618.png" alt="三种交换方式示意图"></p><h4 id="1-电路交换的优缺点"><a href="#1-电路交换的优缺点" class="headerlink" title="1. 电路交换的优缺点"></a>1. 电路交换的优缺点</h4><mark class="hl-label blue">优点</mark> <ul><li><strong>通信时延小</strong>:通信线路为通信双方用户专用，数据直达，连续传输大量数据时，这一优势明显.</li><li><strong>有序传输</strong>:数据只在专用线路上传输，因此不存在失序问题.</li><li><strong>没有冲突</strong>:不同的通信双方拥有不同信道，不会出现争用物理信道的问题.</li><li><strong>使用范围广</strong>:电路交换既适用于传输模拟信号，也适用于传输数字信号.</li><li><strong>实时性强</strong>:通信时延小.</li><li><strong>控制简单</strong></li></ul><mark class="hl-label red">缺点</mark> <ul><li><strong>建立连接时间太长</strong>:电路交换的平均连接时间对计算机通信来说太长了.</li><li><strong>线路独占，使用效率低</strong></li><li><strong>灵活性差</strong>:只要连接所建立的物理通路中的任何一点出现故障，就需要重新建立连接.</li><li><strong>难以规格化</strong>:电路交换时，数据直达，不同类型、不同速度、不同规格的终端很难相互通信,也难以在通信过程中进行<strong>差错控制</strong>.</li></ul><h4 id="2-报文交换的优缺点"><a href="#2-报文交换的优缺点" class="headerlink" title="2. 报文交换的优缺点"></a>2. 报文交换的优缺点</h4><mark class="hl-label blue">优点</mark> <ul><li><strong>无需建立连接</strong>:用户可以随时发送报文.</li><li><strong>动态分配线路</strong>:当发送方将报文发送到结点交换机时，结点交换机先存储整个报文,然后选择一条合适的空闲线路将报文发送出去.</li><li><strong>提高线路可靠性</strong>:如果某条传输线路发生故障，会重新选择一条路径传输数据.</li><li><strong>提高线路利用率</strong>:通信双方不是固定占用一条线路，而是在不同时间分段部分占用物理线路.</li><li><strong>提供多目标服务</strong>:一个报文可以同时发送给多个目的地址.</li></ul><mark class="hl-label red">缺点</mark> <ul><li><strong>引起了转发时延</strong>:结点交换机要存储和转发报文.</li><li><strong>需要较大的存储空间</strong>:报文大小没有限制.</li><li><strong>需要传输额外的信息量</strong>:因为需要携带源地址与目标地址等信息.</li></ul><h4 id="3-分组交换的优缺点"><a href="#3-分组交换的优缺点" class="headerlink" title="3. 分组交换的优缺点"></a>3. 分组交换的优缺点</h4><mark class="hl-label blue">优点</mark> <ul><li><strong>无需建立连接</strong>:用户可以随时发送分组.</li><li><strong>线路利用率高</strong>:通信双方不是占用一条通信线路,而是在不同的时间分段部分占用物理线路.</li><li><strong>简化了存储管理</strong>:相对于报文交换,分组长度固定，相应的缓存区大小也固定，管理起来相对容易.</li><li><strong>加速传输</strong>:由于分组是逐个传输的，这就使得后一个分组的存储操作，与前一个分组的转发操作可以同时进行.</li><li><strong>减少出错概率和数据量</strong>:因为分组比报文小,出错概率必然减小,即便分组出错也只需重传出错的分组.这比重传整个报文的数据量要小的多.不仅提高可靠性也减少了传输时延.</li></ul><mark class="hl-label red">缺点</mark> <ul><li><strong>引起了转发时延</strong>:结点交换机上要经历存储转发的过程.</li><li><strong>需要传输额外的信息量</strong>:将原始报文分割成等长的数据块,每个数据块都要加上源地址和目的地址等控制信息,从而构成分组.</li><li><strong>对于数据包服务，存在失序、丢失或重复分组的问题;对于虚电路服务,存在呼叫建立、数据传输和虚电路释放三个过程</strong></li></ul><h2 id="1-4-计算机网络的定义与分类"><a href="#1-4-计算机网络的定义与分类" class="headerlink" title="1.4 计算机网络的定义与分类"></a>1.4 计算机网络的定义与分类</h2><h3 id="1-4-1-计算机网络的定义"><a href="#1-4-1-计算机网络的定义" class="headerlink" title="1.4.1 计算机网络的定义"></a>1.4.1 计算机网络的定义</h3><ul><li>计算机网络的精确定义并未统一.</li><li>计算机网络最简单的定义是：一些<strong>互连</strong>的、<strong>自治</strong>的计算机的<strong>集合</strong>.<ul><li>互连：指计算机之间可以通过有线或者无线的方式进行数据通信.</li><li>自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用.</li><li>集合：是指至少需要两台计算机.</li></ul></li><li>计算机网络较好的定义是：计算机网络主要是由一些<strong>通用的</strong>、<strong>可编程的硬件互连</strong>而成的.而这些硬件并非专门同来实现某一特定目的(例如，传送数据或视频信号).这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>.<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件.</li><li>计算机网络并非专门用来传送数据，而是能够支持多种的应用(包括今后可能出现的各种应用).</li></ul></li></ul><h3 id="1-4-2-计算机网络的分类"><a href="#1-4-2-计算机网络的分类" class="headerlink" title="1.4.2 计算机网络的分类"></a>1.4.2 计算机网络的分类</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117082826267.png" alt="计算机网络的分类"></p><h2 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h2><h3 id="1-5-1-速率"><a href="#1-5-1-速率" class="headerlink" title="1.5.1 速率"></a>1.5.1 速率</h3><ul><li>比特：计算机中数据量的单位,也是信息论中信息量的单位，一个比特就是二进制数字中的一个1或0.</li><li><strong>速率</strong>：连接在计算机网络上的主机在数字信道上传送比特的速率，也称为<strong>比特率</strong>或<strong>数据率</strong>.</li></ul><h3 id="1-5-2-带宽"><a href="#1-5-2-带宽" class="headerlink" title="1.5.2 带宽"></a>1.5.2 带宽</h3><p><strong>带宽在模拟信号系统中的意义</strong></p><ul><li><strong>信号</strong>所包含的各种不同频率成分所占据的频率范围</li><li>单位：Hz(kHz、MHz、GHz)</li></ul><p><strong>带宽在计算机网络中的意义</strong></p><ul><li>用来表示网络的<strong>通信线路</strong>所能传送的数据的能力，因此网络贷款表示在单位时间内从网络中的某一点到另一点所能通过的”<strong>最高数据率</strong>“.</li><li>单位：b/s(kb/s、Mb/s、Gb/s、Tb/s)</li></ul><blockquote><p>其实，”带宽”的这两种意义表述之间有着密切的联系，一条通信线路的”频带宽度”越宽，其所传输的数据的”最高数据率”也越高.</p></blockquote><h3 id="1-5-3-吞吐量"><a href="#1-5-3-吞吐量" class="headerlink" title="1.5.3 吞吐量"></a>1.5.3 吞吐量</h3><ul><li>吞吐量表示在<strong>单位时间内通过某个网络(或信道、接口)的数据量</strong>.</li><li>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少的数据量能够通过网络.</li><li>吞吐量<strong>受网络的带宽或额定速率的限制</strong>.</li></ul><h3 id="1-5-4-时延"><a href="#1-5-4-时延" class="headerlink" title="1.5.4 时延"></a>1.5.4 时延</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117085339267.png" alt="网络时延"></p><ul><li><p><strong>发送时延</strong></p><script type="math/tex; mode=display">发送时延=\frac{分组长度(b)}{发送速率(b/s)}</script></li><li><p><strong>传播时延</strong></p><script type="math/tex; mode=display">发送时延=\frac{信道长度(m)}{电磁波传播速率(m/s)}</script></li><li><p><strong>处理时延</strong>(一般不方便计算)</p></li></ul><h3 id="1-5-5-时延带宽积"><a href="#1-5-5-时延带宽积" class="headerlink" title="1.5.5 时延带宽积"></a>1.5.5 时延带宽积</h3><script type="math/tex; mode=display">时延带宽积=传播时延\times带宽</script><ul><li>若发送端连续发送数据，则所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特.</li><li>链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>.</li></ul><h3 id="1-5-6-往返时间"><a href="#1-5-6-往返时间" class="headerlink" title="1.5.6 往返时间"></a>1.5.6 往返时间</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117090402533.png" alt="往返时间"></p><h3 id="1-5-7-利用率"><a href="#1-5-7-利用率" class="headerlink" title="1.5.7 利用率"></a>1.5.7 利用率</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117090635135.png" alt="利用率"></p><h3 id="1-5-8-丢包率"><a href="#1-5-8-丢包率" class="headerlink" title="1.5.8 丢包率"></a>1.5.8 丢包率</h3><ul><li>丢包率即<strong>分组丢失率</strong>，是指一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率.</li><li>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等.</li><li>分组丢失主要有两种情况：<ul><li>分组在传输过程中出现了<strong>误码</strong>，被结点丢弃.</li><li>分组到达了一个队列已满的分组交换机时被丢弃，在通信量较大时可能造成网络拥塞.</li></ul></li><li>因此，丢包率反映了网络的拥塞情况<ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%-4%.</li><li>重度拥塞时路径丢包率为5%-15%.</li></ul></li></ul><h2 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h2><h3 id="1-6-1-常见的计算机网络结构"><a href="#1-6-1-常见的计算机网络结构" class="headerlink" title="1.6.1 常见的计算机网络结构"></a>1.6.1 常见的计算机网络结构</h3><ul><li><strong>OSI(开放系统互连参考模型)体系结构</strong>(法律上的国际标准)</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117093943596.png" alt="开放系统互连参考模型"></p><ul><li><p><strong>TCP/IP体系结构</strong>(事实上的国际标准)</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117094437594.png" alt="TCP/IP体系结构"></p></li></ul><h3 id="1-6-2-计算机网络体系结构分层的必要性"><a href="#1-6-2-计算机网络体系结构分层的必要性" class="headerlink" title="1.6.2 计算机网络体系结构分层的必要性"></a>1.6.2 计算机网络体系结构分层的必要性</h3><ul><li><p>计算机网络是一个非常复杂的系统.早在最初的APPANET设计时就提出了分层的设计理念.</p></li><li><p>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较抑郁研究和处理.</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117095659690.png" alt="各层所要解决的问题"></p></li></ul><h3 id="1-6-3-计算机网络体系结构专用术语"><a href="#1-6-3-计算机网络体系结构专用术语" class="headerlink" title="1.6.3 计算机网络体系结构专用术语"></a>1.6.3 计算机网络体系结构专用术语</h3><h4 id="实体-任何可发送或接收信息的硬件或软件进程"><a href="#实体-任何可发送或接收信息的硬件或软件进程" class="headerlink" title="实体 任何可发送或接收信息的硬件或软件进程."></a>实体 任何可发送或接收信息的<strong>硬件</strong>或<strong>软件进程</strong>.</h4><ul><li>对等实体：收发双方<strong>相同层次的实体</strong>.</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117101832771.png" alt="对等实体"></p><h4 id="协议-控制两个对等实体进行逻辑通信的规则的集合"><a href="#协议-控制两个对等实体进行逻辑通信的规则的集合" class="headerlink" title="协议 控制两个对等实体进行逻辑通信的规则的集合"></a>协议 控制两个对等实体进行逻辑通信的规则的集合</h4><p>协议的三个要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>时序：定义收发双方的时序关系</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117102202837.png" alt="协议"></p><h4 id="服务-在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务"><a href="#服务-在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务" class="headerlink" title="服务  在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务"></a>服务  在协议控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务</h4><ul><li><strong>服务访问点</strong> 在同一系统中<strong>相邻的两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型.<ul><li>数据链路层的服务访问点为帧的”类型”字段.</li><li>网络层的服务访问点为IP数据报首部中的”协议字段”.</li><li>运输层的服务访问点为”端口号”</li></ul></li><li><strong>服务原语</strong>  上层使用下层所提供的服务必须通过与下层<strong>交换一些命令</strong>，这些命令称为服务原语.</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117102441954.png" alt="服务"></p><ul><li><strong>协议数据单元PDU</strong>  <strong>对等层次之间传送的数据包</strong>称为该层协议的协议数据单元.</li><li><strong>服务数据单元SDU</strong>  <strong>同一系统内，层与层之间交换的数据包</strong>称为服务数据单元.</li><li>多个SDU可以合成为一个PDU，一个SDU也可划分为几个PDU</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221117103322044.png" alt="协议数据单元"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网路——第二章(物理层)</title>
      <link href="/2022/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-物理层的概念"><a href="#2-1-物理层的概念" class="headerlink" title="2.1 物理层的概念"></a>2.1 物理层的概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，它为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么.</p><h3 id="2-1-1-传输媒体"><a href="#2-1-1-传输媒体" class="headerlink" title="2.1.1 传输媒体"></a>2.1.1 传输媒体</h3><ul><li>导引型传输媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li><li>电力线</li></ul></li><li>非引导型传输媒体<ul><li>微波通信(2-40GHz)</li></ul></li></ul><h3 id="2-1-2-物理层协议的主要任务"><a href="#2-1-2-物理层协议的主要任务" class="headerlink" title="2.1.2 物理层协议的主要任务"></a>2.1.2 物理层协议的主要任务</h3><ol><li><p><strong>机械特性</strong></p><p>指明接口所用接线器的<strong>形状</strong>和<strong>尺寸</strong>、引脚数目和排列、固定和锁定的装置</p></li><li><p><strong>电气特性</strong></p><p>指明在接口电缆的各条线上出现的电压的范围</p></li><li><p><strong>功能特性</strong></p><p>指明某条线上出现的某一电平的<strong>电压表示何种意义</strong></p></li><li><p><strong>过程特性</strong></p><p>指明对于不同功能的各种<strong>可能事件的出现顺序</strong></p></li></ol><h2 id="2-2-物理层下的传输媒体"><a href="#2-2-物理层下的传输媒体" class="headerlink" title="2.2 物理层下的传输媒体"></a>2.2 物理层下的传输媒体</h2><iframe src="//player.bilibili.com/player.html?aid=64680542&bvid=BV1x4411d7HU&cid=115136695&page=15" scrolling="no" border="0" as_wide="1" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h2><iframe src="//player.bilibili.com/player.html?aid=64680542&bvid=BV1x4411d7HU&cid=115136750&page=16" scrolling="no" border="0" as_wide="1" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h2><iframe src="//player.bilibili.com/player.html?aid=64680542&bvid=BV1x4411d7HU&cid=115136804&page=17" scrolling="no" border="0" as_wide="1" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2-5-信道极限容量"><a href="#2-5-信道极限容量" class="headerlink" title="2.5 信道极限容量"></a>2.5 信道极限容量</h2><iframe src="//player.bilibili.com/player.html?aid=64680542&bvid=BV1x4411d7HU&cid=115312308&page=18" scrolling="no" border="0" as_wide="1" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(一)——基础知识</title>
      <link href="/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发编程——基础知识（一）"><a href="#Java并发编程——基础知识（一）" class="headerlink" title="Java并发编程——基础知识（一）"></a>Java并发编程——基础知识（一）</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><strong>进程</strong>：对运行时程序的封装，是<strong>系统进行资源调度和分配的的基本单位，实现了操作系统的并发</strong></li><li><strong>线程</strong>：进程的子任务，<strong>是CPU调度和分派的基本单位</strong>，<strong>用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位</strong>。每个线程都独自占用一个<strong>虚拟处理器</strong>：独自的<strong>寄存器组</strong>，<strong>指令计数器和处理器状态</strong>。每个线程完成不同的任务，但是<strong>共享同一地址空间</strong>（也就是同样的<strong>动态内存，映射文件，目标代码等等</strong>），<strong>打开的文件队列和其他内核资源</strong>。</li></ul><h3 id="1-2-进程与线程的区别"><a href="#1-2-进程与线程的区别" class="headerlink" title="1.2 进程与线程的区别"></a>1.2 进程与线程的区别</h3><ol><li>一个线程只属于一个进程，而一个进程中可以有多个线程，但至少有一个线程，<strong>线程依赖于进程而存在</strong>.</li><li>进程执行过程中拥有独立的内存单元，而多个线程共享进程的内存.(资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享<strong>代码段</strong>（代码和常量），<strong>数据段</strong>（全局变量和静态变量），<strong>扩展段</strong>（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量.)</li><li><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong>.</li><li>由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等.因此，操作系统所付出的开销将显著地大于创建或撤销线程时的开销.类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置.而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作.可见，<strong>进程切换的开销远大于线程切换的开销</strong>.</li><li>由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现也变得容易.进程间通信IPC，线程间可以直接读写进程数据段(如 全局变量)来进行通信——需要同步或互斥手段的辅助，以保证数据的一致性.在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预.</li><li>进程编程调试简单可靠性高，但是创建销毁开销大;线程正相反，开销小，切换速度快，但是编程调试相对复杂.</li><li>进程间不会相互影响，线程中一个线程挂掉可能导致整个进程挂掉.</li><li>进程适应于多核、多机分布，线程适用于多核.</li></ol><h3 id="1-3-进程间的通信方式"><a href="#1-3-进程间的通信方式" class="headerlink" title="1.3 进程间的通信方式"></a>1.3 进程间的通信方式</h3><p>​    进程间的通信主要包括<strong>管道</strong>、系统IPC(包括<strong>消息队列</strong>、信号量、<strong>信号</strong>、共享内存等)以及<strong>套接字socket</strong>.</p><h4 id="1-3-1-管道"><a href="#1-3-1-管道" class="headerlink" title="1.3.1 管道"></a>1.3.1 管道</h4><p>​    管道主要包括匿名管道和命名管道.管道可用于具有亲缘关系的父子进程间的通信.命名管道除了具有管道所具有的所有功能外，它还允许无亲缘关系的进程间的通信.</p><ul><li><strong>匿名管道PIPE</strong>：<ol><li>它是半双工的(即数据只能在一个方向上流动)，具有固定的读端和写端.</li><li>它只能用于具有亲缘关系的进程间通信(父子进程或兄弟进程).</li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数.但它不是普通的文件，并不属于其他任何的文件系统，并且只存在于内存中.</li></ol></li><li><strong>命名管道FIFO</strong>:<ol><li>FIFO可以在无关的进程中交换数据.</li><li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中.</li></ol></li></ul><h4 id="1-3-2-系统IPC"><a href="#1-3-2-系统IPC" class="headerlink" title="1.3.2 系统IPC"></a>1.3.2 系统IPC</h4><ul><li><p><strong>消息队列</strong>：</p><p>  消息队列是消息的链接表，存放在内核中.一个消息队列由一个标识符(即队列ID)来标记(消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限的进程可以按照一定的规则向消息队列中添加新的信息.对消息队列有读权限的进程可以从中读取信息.</p><p>  ==特点:==</p><ol><li>消息队列是面向记录的.其中的消息具有特定的格式和特定的优先级.</li><li>消息队列独立于发送和接受进程.进程终止时，消息队列中的内容并不会被删除.</li><li>消息队列可以实现消息的随机查询.消息不一定要以先进先出的次序读取，也可以按消息的类型读取.</li></ol></li><li><p><strong>信号量</strong>:</p><p>  信号量与已经介绍过的IPC结构不同，它是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问.信号量用于实现进程间的互斥同步，而不是用于存储进程间的通信数据.</p><p>  ==特点:==</p><ol><li>信号量用于进程间同步，若要进程间传递数据需要结合共享内存使用.</li><li>信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作.</li><li>每次对信号量的PV操作不仅限于对信号量值加1或减1,而且可以加减任意正整数.</li><li>支持信号量组</li></ol></li><li><p><strong>信号</strong>：</p><p>  信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生.</p></li><li><p><strong>共享内存</strong>:</p><p>  它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新.这种方式需要依靠某种同步操作，如互斥锁和信号量等.</p><p>  ==特点:==</p><ol><li>共享内存是最快的一种IPC，因为进程是直接对内存进行读取.</li><li>因为多个进程可以同时操作，所以需要进程同步</li><li>信号量+共享内存通常要结合在一起使用,信号量用来同步对共享内存的访问.</li></ol></li></ul><h4 id="1-3-3-套接字"><a href="#1-3-3-套接字" class="headerlink" title="1.3.3 套接字"></a>1.3.3 套接字</h4><p>​    socket也是一种进程间通信机制.与其他通信机制不同的是，它可以用于不通主机之间的通信</p><h3 id="1-4-线程间通信方式"><a href="#1-4-线程间通信方式" class="headerlink" title="1.4 线程间通信方式"></a>1.4 线程间通信方式</h3><ol><li><strong>临界区</strong>：通过多线程的串行化来访问公共资源或一段代码,速度快，适合控制数据访问.</li><li><strong>互斥量Synchronized/Lock</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问.</li><li><strong>信号量Semphare</strong>:为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目.</li><li><strong>事件(信号)，Wait/Notify</strong>:通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作.</li></ol><h2 id="二、并发与并行"><a href="#二、并发与并行" class="headerlink" title="二、并发与并行"></a>二、并发与并行</h2><ol><li><strong>并发</strong>：多个进程在一个CPU下采用时间片轮转方式，在一段时间内，让多个进程得以推进，类似“雨露均沾”思想，一个CPU在短时间内会自动调度不同任务.(同一时间间隔内，多个事件交替发生)</li><li><strong>并行</strong>：多个任务在多个CPU分别同时运行，这称之为并行.(同一时刻，多个事件发生)</li></ol><h2 id="三、线程的风险"><a href="#三、线程的风险" class="headerlink" title="三、线程的风险"></a>三、线程的风险</h2><ol><li><strong>线程安全性问题</strong>：多线程环境下，程序的运行结果与预期不符.(伴生现象：不容易复现)</li><li><strong>线程的活跃度问题</strong>：<ul><li><strong>死锁</strong>：指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去</li><li><strong>饥饿</strong>：如果线程优先级“不均”，并且CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。饥饿嘛，线程一直得不到CPU时间，一直被饿着.</li><li><strong>活锁</strong>：线程拿到锁，却又相互释放锁，不执行功能.</li></ul></li><li><strong>线程的性能问题</strong>：</li></ol><ul><li><strong>消耗时间</strong>:线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失.</li><li><strong>消耗CPU和内存</strong>：如果发生大量的线程被创建、执行和销毁，这可是非常耗CPU和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM.</li><li><strong>容易导致GC频繁的执行</strong>:大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿.</li><li><strong>线程的上下文切换</strong>:在线程调度过程中需要访问由操作系统和JVM共享的数据结构。应用程序、操作系统以及JVM都使用一组相同的CPU，在JVM和操作系统的代码中消耗越多的CPU时钟周期，应用程序的可用CPU时钟周期就越来越少。当一个新的线程被切换进来时，它所需要的数据可能不在当前处理器的本地缓存中，因此上下文切换将导致一些缓存缺失，因而线程在首次调度运行时会更加缓慢。</li></ul><hr><p>参考文章：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1688297">进程和线程的概念、区别及进程线程间通信</a></li><li><a href="https://juejin.cn/post/6971968226804629517">java并发编程：多线程带来的安全风险问题</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2022/10/16/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/16/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="一、版本控制-VCS"><a href="#一、版本控制-VCS" class="headerlink" title="一、版本控制(VCS)"></a>一、版本控制(VCS)</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="1、本地版本控制系统"><a href="#1、本地版本控制系统" class="headerlink" title="1、本地版本控制系统"></a>1、本地版本控制系统</h3><h3 id="2、集中化的版本控制系统-CVCS"><a href="#2、集中化的版本控制系统-CVCS" class="headerlink" title="2、集中化的版本控制系统(CVCS)"></a>2、集中化的版本控制系统(CVCS)</h3><p>这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新.</p><h3 id="3、分布式版本控制系统-DVCS"><a href="#3、分布式版本控制系统-DVCS" class="headerlink" title="3、分布式版本控制系统(DVCS)"></a>3、分布式版本控制系统(DVCS)</h3><p>在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><h2 id="二、Git基础"><a href="#二、Git基础" class="headerlink" title="二、Git基础"></a>二、Git基础</h2><h3 id="1、Git的特点"><a href="#1、Git的特点" class="headerlink" title="1、Git的特点"></a>1、Git的特点</h3><h4 id="1、直接记录快照，而非差异比较"><a href="#1、直接记录快照，而非差异比较" class="headerlink" title="1、直接记录快照，而非差异比较"></a>1、直接记录快照，而非差异比较</h4><p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221017150533537.png" alt="存储每个文件与初始版本的差异"></p><p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221017150446022.png" alt="存储项目随时间改变的快照"></p><h4 id="2、近乎所有操作都是本地执行"><a href="#2、近乎所有操作都是本地执行" class="headerlink" title="2、近乎所有操作都是本地执行"></a>2、近乎所有操作都是本地执行</h4><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><h4 id="3、Git保证完整性"><a href="#3、Git保证完整性" class="headerlink" title="3、Git保证完整性"></a>3、Git保证完整性</h4><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code></p><h4 id="4、Git一般只添加数据"><a href="#4、Git一般只添加数据" class="headerlink" title="4、Git一般只添加数据"></a>4、Git一般只添加数据</h4><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h4 id="5、三种状态"><a href="#5、三种状态" class="headerlink" title="5、三种状态"></a>5、三种状态</h4><p>Git 有三种状态，你的文件可能处于其中之一：<mark class="hl-label blue">已提交(committed)</mark> 、<mark class="hl-label red">已修改(modified)</mark>  和 <mark class="hl-label green">已暂存(staged)</mark> 。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221017152929816.png" alt="工作目录、暂存区域以及 Git 仓库"></p><p><code>Git仓库目录</code>: 是Git用来保存<strong>项目的元数据和对象数据库</strong>的地方。 这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p><code>工作目录</code>: 是对项目的<strong>某个版本独立提取出来的内容</strong>。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><code>暂存区域</code>: 是一个文件，<strong>保存了下次将提交的文件列表信息</strong>，一般在 Git 仓库目录中。 有时候也被称作”索引”，不过一般说法还是叫暂存区域。</p><p>基本的 Git 工作流程如下：</p><p>1、在工作目录中修改文件。</p><p>2、暂存文件，将文件的快照放入暂存区域。</p><p>3、提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p><h3 id="2、初次运行Git前的配置"><a href="#2、初次运行Git前的配置" class="headerlink" title="2、初次运行Git前的配置"></a>2、初次运行Git前的配置</h3><p>Git自带一个 <code>git config</code> 的工具来帮助设置控制Git外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li><li>当前使用仓库的Git目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li></ol><p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p><h4 id="1、用户信息"><a href="#1、用户信息" class="headerlink" title="1、用户信息"></a>1、用户信息</h4><p>配置用户的名称和邮箱，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><h4 id="2、文本编辑器"><a href="#2、文本编辑器" class="headerlink" title="2、文本编辑器"></a>2、文本编辑器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure><h4 id="3、检查配置信息"><a href="#3、检查配置信息" class="headerlink" title="3、检查配置信息"></a>3、检查配置信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config &lt;key&gt; <span class="comment">#检查Git的某一个配置 ,如 git config user.name</span></span><br></pre></td></tr></table></figure><h4 id="4、获取帮助"><a href="#4、获取帮助" class="headerlink" title="4、获取帮助"></a>4、获取帮助</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line">man git-&lt;verb&gt; <span class="comment">#例如想要获取config命令的手册，执行git help config</span></span><br></pre></td></tr></table></figure><h3 id="3、获取Git仓库"><a href="#3、获取Git仓库" class="headerlink" title="3、获取Git仓库"></a>3、获取Git仓库</h3><h4 id="1、在现有目录中初始化仓库"><a href="#1、在现有目录中初始化仓库" class="headerlink" title="1、在现有目录中初始化仓库"></a>1、在现有目录中初始化仓库</h4><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code> 命令来实现对指定文件的跟踪，然后执行 <code>git commit</code> 提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add LICENSE</span><br><span class="line">git commit -m <span class="string">&#x27;initial project version&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2、克隆现有仓库"><a href="#2、克隆现有仓库" class="headerlink" title="2、克隆现有仓库"></a>2、克隆现有仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url] 自定义名</span><br></pre></td></tr></table></figure><h3 id="4、记录每次更新到仓库"><a href="#4、记录每次更新到仓库" class="headerlink" title="4、记录每次更新到仓库"></a>4、记录每次更新到仓库</h3><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221017204548423.png" alt="文件的状态变化周期"></p><h4 id="1、检查当前文件的状态"><a href="#1、检查当前文件的状态" class="headerlink" title="1、检查当前文件的状态"></a>1、检查当前文件的状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="2、跟踪新文件或暂存已修改文件"><a href="#2、跟踪新文件或暂存已修改文件" class="headerlink" title="2、跟踪新文件或暂存已修改文件"></a>2、跟踪新文件或暂存已修改文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt; <span class="comment"># 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</span></span><br></pre></td></tr></table></figure><h4 id="3、状态简览"><a href="#3、状态简览" class="headerlink" title="3、状态简览"></a>3、状态简览</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status -s <span class="comment"># git status --short</span></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><ul><li><strong>MM</strong>: 左边的M表示该文件被修改并放入了暂存区，右边的M表示该文件被修改但是还没有被放入暂存区</li><li><strong>A</strong>: 表示新添加到暂存区的文件</li><li><strong>??</strong>:表示新添加的未跟踪的文件</li></ul><h4 id="4、忽略文件"><a href="#4、忽略文件" class="headerlink" title="4、忽略文件"></a>4、忽略文件</h4><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被Git忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个.gitignore文件的例子</span></span><br><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h4 id="5、查看已暂存和未暂存的文件"><a href="#5、查看已暂存和未暂存的文件" class="headerlink" title="5、查看已暂存和未暂存的文件"></a>5、查看已暂存和未暂存的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff [file] <span class="comment"># 查看已修改但未暂存的部分</span></span><br><span class="line">git diff --staged <span class="comment"># git diff --cached 查看已暂存但未提交的部分</span></span><br></pre></td></tr></table></figure><h4 id="6、提交更新"><a href="#6、提交更新" class="headerlink" title="6、提交更新"></a>6、提交更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit <span class="comment"># 调用文本编辑器输入提交信息</span></span><br><span class="line">git commit -m  message <span class="comment"># 与git commit 同行提交信息</span></span><br></pre></td></tr></table></figure><h4 id="7、跳过使用暂存区"><a href="#7、跳过使用暂存区" class="headerlink" title="7、跳过使用暂存区"></a>7、跳过使用暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m message <span class="comment"># 自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span></span><br></pre></td></tr></table></figure><h4 id="8、移除文件"><a href="#8、移除文件" class="headerlink" title="8、移除文件"></a>8、移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ gittest git:(main) ✗ git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   README</span><br><span class="line">deleted:    test.txt</span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached README</span><br><span class="line"><span class="comment"># git rm 命令后可以列出文件或者目录的名字，也可以使用glob模式，例如</span></span><br><span class="line"><span class="comment"># git rm log/\*.log</span></span><br></pre></td></tr></table></figure><h4 id="9、移动文件"><a href="#9、移动文件" class="headerlink" title="9、移动文件"></a>9、移动文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> file_from file_to</span><br><span class="line"><span class="comment"># 相当于执行三条命令</span></span><br><span class="line"><span class="comment"># mv file_from file_to</span></span><br><span class="line"><span class="comment"># git rm file_from </span></span><br><span class="line"><span class="comment"># git add file_to</span></span><br></pre></td></tr></table></figure><h4 id="10、查看提交历史"><a href="#10、查看提交历史" class="headerlink" title="10、查看提交历史"></a>10、查看提交历史</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 默认不用任何参数的话，git log 会按提交时间列出所有的更新</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment">#如果你想看到每次提交的简略的统计信息，你可以使用 --stat 选项</span></span><br></pre></td></tr></table></figure><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明.<code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。</p><p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交</p><p>更多用法：<a href="https://www.progit.cn/#_viewing_history">git log的更多参数用法</a></p><h4 id="11、撤销操作"><a href="#11、撤销操作" class="headerlink" title="11、撤销操作"></a>11、撤销操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend <span class="comment">#这个命令会将暂存区中的文件提交</span></span><br></pre></td></tr></table></figure><h4 id="12、取消暂存文件"><a href="#12、取消暂存文件" class="headerlink" title="12、取消暂存文件"></a>12、取消暂存文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file <span class="comment"># 取消暂存</span></span><br></pre></td></tr></table></figure><h4 id="13、撤销对文件的修改"><a href="#13、撤销对文件的修改" class="headerlink" title="13、撤销对文件的修改"></a>13、撤销对文件的修改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file <span class="comment"># 撤销对文件的修改</span></span><br></pre></td></tr></table></figure><h3 id="5、远程仓库的使用"><a href="#5、远程仓库的使用" class="headerlink" title="5、远程仓库的使用"></a>5、远程仓库的使用</h3><h4 id="1、查看远程仓库"><a href="#1、查看远程仓库" class="headerlink" title="1、查看远程仓库"></a>1、查看远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote </span><br><span class="line">git remote -v <span class="comment"># 查看仓库url</span></span><br></pre></td></tr></table></figure><h4 id="2、添加远程仓库"><a href="#2、添加远程仓库" class="headerlink" title="2、添加远程仓库"></a>2、添加远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><h4 id="3、从远程仓库中抓取与拉取"><a href="#3、从远程仓库中抓取与拉取" class="headerlink" title="3、从远程仓库中抓取与拉取"></a>3、从远程仓库中抓取与拉取</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name] <span class="comment">#必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作</span></span><br><span class="line">git pull </span><br><span class="line"><span class="comment">#如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 git pull 命令来自动的抓取然后合并远程分支到当#前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</span></span><br></pre></td></tr></table></figure><h4 id="4、推送到远程仓库"><a href="#4、推送到远程仓库" class="headerlink" title="4、推送到远程仓库"></a>4、推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure><h4 id="5、查看远程仓库"><a href="#5、查看远程仓库" class="headerlink" title="5、查看远程仓库"></a>5、查看远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name] <span class="comment"># 查看远程仓库更多的信息</span></span><br></pre></td></tr></table></figure><h4 id="6、远程仓库的移除与重命名"><a href="#6、远程仓库的移除与重命名" class="headerlink" title="6、远程仓库的移除与重命名"></a>6、远程仓库的移除与重命名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rename  <span class="comment"># 重命名远程仓库</span></span><br><span class="line">git remote <span class="built_in">rm</span> [remote-name]</span><br></pre></td></tr></table></figure><h3 id="6、打标签"><a href="#6、打标签" class="headerlink" title="6、打标签"></a>6、打标签</h3><p>Git 使用两种主要类型的标签：<mark class="hl-label blue">轻量标签(lightweight)</mark> 与 <mark class="hl-label red">附注标签(annotated)</mark> 。</p><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="comment"># 列出标签</span></span><br><span class="line">git tag -l <span class="string">&#x27;v1.8.5*&#x27;</span> <span class="comment"># 匹配v1.8.5系列的标签</span></span><br><span class="line">git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span> <span class="comment">#创建附注标签</span></span><br><span class="line">git show &lt;labelname&gt; <span class="comment"># 展示标签信息</span></span><br><span class="line">git tag &lt;labelname&gt;</span><br><span class="line"><span class="comment">#另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后期打标签</span></span><br><span class="line">git tag -a v1 校验和 </span><br><span class="line"></span><br><span class="line"><span class="comment">#共享标签</span></span><br><span class="line">git push [remote-name] [tagname]</span><br><span class="line">git push [remote-name] --tags <span class="comment">#所有不在远程仓库上的标签</span></span><br></pre></td></tr></table></figure><h3 id="7、Git别名"><a href="#7、Git别名" class="headerlink" title="7、Git别名"></a>7、Git别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="三、Git分支"><a href="#三、Git分支" class="headerlink" title="三、Git分支"></a>三、Git分支</h2><h3 id="1、分支简介"><a href="#1、分支简介" class="headerlink" title="1、分支简介"></a>1、分支简介</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p><p>或许你还记得 <a href="https://www.progit.cn/#_getting_started">起步</a> 的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 <a href="https://www.progit.cn/#_getting_started">起步</a> 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221018182904516.png" alt="首次提交对象及其树结构"></p><p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221018182959883.png" alt="提交对象及其父对象"></p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/image-20221018185215082.png" alt="分支及其提交历史"></p><h3 id="2、创建分支"><a href="#2、创建分支" class="headerlink" title="2、创建分支"></a>2、创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt; <span class="comment">#git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去</span></span><br><span class="line">git <span class="built_in">log</span> --online --decorate <span class="comment">#查看当前各个分支所指的对象</span></span><br></pre></td></tr></table></figure><h3 id="3、分支切换"><a href="#3、分支切换" class="headerlink" title="3、分支切换"></a>3、分支切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate --graph --all <span class="comment">#输出你的提交历史、各个分支的指向以及项目的分支分叉情况</span></span><br></pre></td></tr></table></figure><h3 id="4、分支的新建与合并"><a href="#4、分支的新建与合并" class="headerlink" title="4、分支的新建与合并"></a>4、分支的新建与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; <span class="comment"># 新建并切换到新建分支</span></span><br><span class="line">git branch -d &lt;branch-name&gt; <span class="comment"># 删除分支</span></span><br><span class="line">git merge &lt;branch-name&gt; <span class="comment"># 合并分支</span></span><br><span class="line"><span class="comment"># 合并分支出现冲突，解决冲突后运行 git add 和git commit</span></span><br><span class="line">git branch <span class="comment"># 列出分支列表</span></span><br><span class="line">git branch -v <span class="comment"># 查看每一个分支的最后一次提交</span></span><br><span class="line">git branch --merged <span class="comment"># 已经合并到当前分支的分支</span></span><br><span class="line">git branch --no-merged <span class="comment"># 没有合并到当前分支的分支</span></span><br></pre></td></tr></table></figure><h3 id="5、远程分支"><a href="#5、远程分支" class="headerlink" title="5、远程分支"></a>5、远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt; <span class="comment">#从远程分支拉取数据，并不会自动合并</span></span><br><span class="line">git checkout -b &lt;local-branch-name&gt; &lt;remote-branch-name&gt; <span class="comment">#git checkout -b serverfix origin/serverfix</span></span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt; <span class="comment"># 推送到远程仓库的分支上</span></span><br><span class="line"><span class="comment"># git push origin serverfix:awesomebranch 将本地serverfix 分支推送到远程仓库的awesomebranch分支上</span></span><br><span class="line">git checkout --track origin/serverfix <span class="comment"># 跟踪分支 git clone 会自动创建跟踪分支</span></span><br><span class="line">git branch -u origin/serverfix <span class="comment"># 设置已有的本地分支来跟踪一个刚刚拉下来的远程分支</span></span><br><span class="line">git branch -vv <span class="comment"># 查看所有跟踪分支</span></span><br><span class="line">git push origin --delete serverfix <span class="comment"># 删除远程分支</span></span><br></pre></td></tr></table></figure><h3 id="6、变基"><a href="#6、变基" class="headerlink" title="6、变基"></a>6、变基</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim学习</title>
      <link href="/2022/10/14/Vim%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/14/Vim%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="vim学习"><a href="#vim学习" class="headerlink" title="vim学习"></a>vim学习</h1><blockquote><p>四种模式</p></blockquote><ul><li>Insert模式</li><li>normal模式</li><li>visual模式(按v进入)<ul><li>使用 <code>V</code> 选择行</li><li>使用 <code>ctrl + v</code> 进行方框选择</li></ul></li><li>command模式<ul><li>保存: <code>w</code>  退出：<code>q</code></li><li>分屏: <code>vs</code>(vertical split)   <code>sp</code>(split)</li><li><code>% s/目标/替换后/g</code> 全局替换等</li></ul></li></ul><blockquote><p>进入插入模式</p></blockquote><p><code>a</code>: 光标后插入 (append)</p><p><code>i</code>: 光标前插入(insert)</p><p><code>o</code>: 当前行下面一行插入(open a line below)</p><p><code>A</code>: 在当前行最后插入(append after line)</p><p><code>I</code>: 在当前行最前面插入(insert before line)</p><p><code>O</code>: 在当前行上方插入(append a line above)</p><blockquote><p>Insert模式下编辑</p></blockquote><p><code>ctrl + h</code>:删除上一个字符</p><p><code>ctrl + w</code>:删除上一个单词</p><p><code>ctrl + u</code>:删除当前行</p><p><code>ctrl + c 或者 ctrl + [</code> : 替代Esc</p><p><code>gi</code>:快速跳转到最后一次编辑的地方并进入插入模式</p><blockquote><p>Normal模式下编辑</p></blockquote><p><code>x</code>:快速删除一个字符</p><p><code>dw</code>:删除一个单词</p><p><code>dd</code>:删除整行</p><p><code>dt+文本</code>: 删除文本内内容</p><p><code>d + 0</code>: 删除行首</p><p><code>d + $</code>: 删除行尾</p><p><code>rchar</code>:替换一个字符</p><p><code>s</code>:删除当前字符并进入插入模式</p><p><code>S</code>:删除整行进入插入模式</p><p><code>caw</code>:删除一个单词并进入插入模式</p><p><code>ct+文本</code>:删除文本内内容</p><p><code>/ 或者?</code>:进行 向前或者反向搜索</p><p><code>n或者N</code>:跳转到下一个或者上一个匹配</p><p><code>*或者#</code>:进行当前单词的向前或者向后匹配</p><blockquote><p>Normal模式下复制与粘贴</p></blockquote><p><code>y</code>:复制，也可以使用<code>yy</code>复制整行，配合文本对象使用，如：<code>yiw</code>复制一个单词</p><p><code>p</code>:粘贴</p><p><code>d</code>:剪贴</p><blockquote><p>Insert模式下的复制与粘贴</p></blockquote><p><code>set autoindent</code> :设置自动缩进</p><p><code>set paste</code> 和 <code>set nopaste</code>: 解决缩进混乱的问题</p><p><code>&quot;&#123;register&#125;</code> : 前缀指定寄存器，不指定默认使用无名寄存器</p><ul><li><code>&quot;ayiw</code>:复制一个单词到寄存器a中</li><li><code>&quot;bdd</code>: 删除当前行到寄存器b中</li></ul><p><code>:reg &#123;register&#125;</code>:查看寄存器register中存放的内容</p><p><code>&quot;register</code>: 使用寄存器register</p><p><code>&quot;+y</code>:复制到系统剪贴板</p><p><code>set clipboard = unnamed</code>  </p><blockquote><p>移动</p></blockquote><p><code>h</code>:向左移动</p><p><code>j</code>:向下移动</p><p><code>k</code>:向上移动</p><p><code>l</code>:向右移动</p><p><code>w</code>: 移动到下一个单词(非空白符分割)的开头</p><p><code>W</code>: 移动到下一个单词(空白符分割)的开头</p><p><code>e</code>: 移动到下一个单词(空白符分割)的结尾</p><p><code>E</code>: 移动到下一个单词(空白符分割)的结尾</p><blockquote><p>行间搜索移动</p></blockquote><p><code>fchar</code>: 移动到<em>char</em>上，<code>tchar</code>移动到<em>char</em>的前一个字符上，第一次没有搜索到可以使用<code>;</code>/<code>,</code> 继续在该行搜索<code>下一个</code>/<code>上一个</code> ，<code>F</code> 反过来搜索前面的字符</p><p><code>0</code>:移动到行首第一个字符</p><p><code>^</code>:移动到行首第一个非空白字符</p><p><code>$</code>:移动到行尾</p><p><code>g_</code>:移动到行尾非空白字符</p><p><code>()</code>:句子之间移动</p><p><code>&#123;&#125;</code>:段落间移动</p><p><code>gg</code>:移动到文件开头</p><p><code>G</code>:移动到问价结尾</p><p><code>ctrl + o</code>:快速返回</p><p><code>H/M/L</code>:跳转到屏幕的开头(Head),中间(Middle)和结尾(Lower)</p><p><code>ctrl + u</code>:上翻页(upword)</p><p><code>ctrl + f</code>:下翻页(forword)</p><p><code>zz</code>:把当前行置为屏幕中间</p><blockquote><p>替换命令</p></blockquote><p><code>:[range] s/&#123;pattern&#125;/&#123;string&#125;/[flags]</code> :替换</p><ul><li>range表示范围，比如10,20表示10-20行，<code>%</code>表示全部</li><li>pattern表示要替换的模式，string表示替换后的文本</li><li>flags表示替换标志<ul><li><code>g</code>(global)表示全局范围内执行</li><li><code>c</code>(confirm)表示确认，可以确认或者拒绝修改</li><li><code>n</code>(numbr)报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul></li></ul><blockquote><p>多文件操作</p></blockquote><ul><li><p>Buffer切换</p><ul><li>使用<code>:ls</code>会列举当前缓存区，然后使用<code>:b n</code> 跳转到第n个缓存区</li><li><code>:bpre</code>  <code>:bnext</code>  <code>:bfirst</code>  <code>:blast</code></li><li><code>:b</code> buffer_name + TAB补全</li></ul></li><li><p>Windows窗口</p><ul><li><code>ctrl + w + s</code> 或 <code>sp</code>: 水平分割</li><li><code>ctrl + w + v</code> 或 <code>vs</code>: 垂直分割</li></ul><p><img src="https://tuchuang-1259758352.cos.ap-nanjing.myqcloud.com/img/%E6%88%AA%E5%B1%8F2022-10-13%2009.08.52.png" alt="截屏2022-10-13 09.08.52"></p></li></ul><blockquote><p>文本对象操作</p></blockquote><p><code>[number] &lt;command&gt; [text object]</code></p><ul><li>number表示次数，commad表示命令，如<code>d</code>(elete),<code>c</code>(hange),<code>y</code>(ank)</li><li>text object是要操作的文本对象，比如单词<code>w</code> ，句子<code>s</code>，段落 <code>p</code></li></ul><blockquote><p>Vim宏</p></blockquote><p><code>q&#123;register&#125;</code>:录制到寄存器register中</p><p><code>q</code>:停止宏录制</p><p><code>:normal @&#123;register&#125;</code>:播放寄存器register中的宏</p><p> <a href="../../../Myblog/source/css/演示春风楷.ttf">演示春风楷.ttf</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法总结</title>
      <link href="/2022/01/21/Markdown%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/21/Markdown%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天和前天经过<code>极其痛苦</code> 配置过程，最后我的个人博客终于搭建成功了！！！（当然，博客的搭建过程并不复杂，只是喜欢追求完美的我，总是因为一点点的瑕疵就感到不满意，然后就想着解决，奈何<code>技术太菜</code>，所以只能时间来凑.好了，博客搭建好了，那么接下来自然而然就是通过它来记录学习过程了。所以自然就想到了Markdown。博客不同于word排版，通过框选、点击相应的按钮等操作就可以实现想要的效果，markdown完全是键盘操作，想要什么样的效果，完全是通过相应的语法来实现，也就是通过不同的符号和格式来实现。那么废话不多说，开始Markdown的语法的学习。</p><h2 id="一、Markdown-纯文本基本语法"><a href="#一、Markdown-纯文本基本语法" class="headerlink" title="一、Markdown 纯文本基本语法"></a>一、Markdown 纯文本基本语法</h2><h3 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a><strong>1、标题</strong></h3><p>正如我们日常写课程报告一样，不同大小的标题显得文章更有层次感。那么Markdown中的不同的标题是通过<code>#</code>的个数来区分的，个数从1-6字体一次减小，常用的为标题二，也就是本小结的标题<code>一、Markdown纯文本基本语法</code>这样的大小（<code>1、标题</code>为标题三）。<br><strong>使用方法：</strong><code>#</code>个数+<code>空格</code>+<code>标题</code></p><h3 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a><strong>2、字体</strong></h3><p>在基本用法中，常用的就是<code>加粗</code>、<code>斜体</code>、<code>删除线</code>、<code>下划线</code>等这些操作。</p><ul><li><strong>加粗和斜体</strong><br><strong>加粗</strong>和<strong>斜体</strong>是通过<code>*</code>或者<code>_</code>的个数来控制的。我就用<code>*</code>来演示。一个<code>*</code>代表<em>倾斜</em>，两个代表<strong>加粗</strong>,三个代表 <strong><em>加粗倾斜</em></strong>。<br><strong>使用方法：</strong><code>*</code>个数+<code>内容</code>+<code>*</code>个数。如 <code>** 我最棒 **</code>。如果在使用过程中有无法识别的情况，请注意空格的使用。</li><li><strong>删除线</strong><br>在我们浏览公众号时经常会看到 “<strong><del>我可以</del></strong>“这样的写法，那么就是删除线的是用。在Markdown中使用<code>~~</code>+<code>内容</code>+<code>~~</code>的格式来呈现出删除线的效果。需要注意的是这里的<code>~~</code>是英文中的，如果未能实现想要的效果，可能是中英文输入的问题。</li><li><strong>下划线</strong><br>下划线在word中可以说很简单的操作，但是在Markdown中就不是那么容易了。想要实现下划线的效果，需要写一长串的符号：<code>&lt;span style=&quot;border-bottom:2px dashed red&quot;&gt;</code>+<code>内容</code>+<code>&lt;/span&gt;</code>。这个当然是自定义程度最高的了，涉及到css的语法，可以定义下划线的宽度、样式以及颜色。比如,<span style="border-bottom:2px solid blue;">Hello World</span><br>。如果为了简单那么可以使用u标签，也就是<code>&lt;u&gt;</code>+<code>内容</code>+<code>&lt;/u&gt;</code>，比如：<u>Hello World</u>。可以看到这是最平常的一种样式。如果只需要简单使用下划线，那么可以用第二种方式。</li></ul><h3 id="3、分割线"><a href="#3、分割线" class="headerlink" title="3、分割线"></a><strong>3、分割线</strong></h3><p>在日常的博客中，分割线必不可少。在Markdown中你可以使用<code>三个以上</code>的 <code>*</code>、<code>-</code>、<code>_</code>来做出分割线，但行内不能有其他内容。比如：</p><hr><p>上面就是三个<code>*</code>做出来的分割线。</p><h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a><strong>4、引用</strong></h3><p>在需要引用的文字前在上<code>&gt;</code>即可。以下例子引用<code>罗素</code>的<code>我为什么活着</code>。</p><blockquote><p>  对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁但无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。</p><p>  我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈，以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情解除孤寂——那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想象的天空景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。<br>  我以同样的热情寻求知识，我希望了解人的心灵。我希望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。</p><p>  爱情和知识，尽可能地把我引上天堂，但同情心总把我带回尘世。痛苦的呼号的回声在我心中回荡，饥饿的儿童，被压迫者折磨的受害者，被儿女视为可厌负担的无助的老人，以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。<br>  这就是我的一生，我觉得它值得活。如果有机会的话，我还乐意再活一次。</p></blockquote><p>当然你可以在引用中嵌套其他用法，这里不在赘述。</p><h3 id="5、列表"><a href="#5、列表" class="headerlink" title="5、列表"></a><strong>5、列表</strong></h3><ul><li><strong>无序列表</strong><br>在Markdown中可以使用单个的<code>-</code>、<code>*</code>、<code>+</code>来实现无序列表的标记。如<code>-</code>+<code>实例一</code>。当然记住标记与内容要用空格隔开。如：</li><li>中国</li><li>美国</li><li>日本</li></ul><p>无序列表可以嵌套，下一级在上一级的基础上加三个空格即可。如这样写：</p><blockquote><p>&nbsp;- 中国</p><p> &nbsp;&nbsp;&nbsp;- 日本</p><p>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;- 美国 </p></blockquote><p><code>效果：</code></p><ul><li>中国<ul><li>日本<ul><li>美国</li></ul></li></ul></li></ul><ul><li><strong>有序列表</strong><br>有序列表的用法为<code>数字（1、2 、3……）</code>+<code>.(英文句号）</code>+’空格’+<code>内容</code>。如以下：</li></ul><ol><li>中国</li><li>美国</li><li>日本</li></ol><h3 id="6、表格"><a href="#6、表格" class="headerlink" title="6、表格"></a><strong>6、表格</strong></h3><p>如果需要在博客中加入表格，那么可以用下面的语法：<br><code>表头|表头|表头</code><br><code>-|:-:|-:</code><br><code>内容|内容|内容</code><br><code>内容|内容|内容</code><br><code>效果如下：</code></p><div class="table-container"><table><thead><tr><th>国家</th><th style="text-align:center">人口</th><th style="text-align:right">排名</th></tr></thead><tbody><tr><td>中国</td><td style="text-align:center">14</td><td style="text-align:right">No.1</td></tr><tr><td>美国</td><td style="text-align:center">2.2</td><td style="text-align:right">No.2</td></tr></tbody></table></div><p>默认文字居中，<code>-</code>两边都加代表文字居中，<code>-</code>加在右边代表文字居右</p><h3 id="7、代码"><a href="#7、代码" class="headerlink" title="7、代码"></a><strong>7、代码</strong></h3><p>程序员嘛，在写博客时肯定缺少不了贴代码。Markdown中可以用两个<code>反引号</code>来标记代码。也可以用<code>``` </code>来显示代码段。如果这样写：<code>```java</code>+<code>代码</code>+<code>``` </code>，则代表java代码，实例效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Markdown纯文本进阶语法"><a href="#二、Markdown纯文本进阶语法" class="headerlink" title="二、Markdown纯文本进阶语法"></a>二、Markdown纯文本进阶语法</h2><p>为了使自己的博客内容排版更好看一点，就需要学习更过知识了。</p><h3 id="1、更改字体、大小、颜色"><a href="#1、更改字体、大小、颜色" class="headerlink" title="1、更改字体、大小、颜色"></a><strong>1、更改字体、大小、颜色</strong></h3><p><code>语法：</code> <code>&lt;font face =&quot;宋体&quot;&gt;内容&lt;/font&gt;</code>、<code>&lt;font color=yellow&gt;内容&lt;/font&gt;</code>、<code>&lt;font size=5&gt;内容&lt;/font&gt;</code>。</p><p>例子：<code>&lt;font size=6 color= blue face=&quot;宋体&quot;&gt;Hello World!&lt;/font&gt;</code></p><p><code>效果：</code> <font size=5 color= blue face="宋体">Hello World!</font></p><h3 id="2、为文字添加背景色"><a href="#2、为文字添加背景色" class="headerlink" title="2、为文字添加背景色"></a><strong>2、为文字添加背景色</strong></h3><p>当然这个添加背景色是整个一行都会添加。</p><p><code>语法</code>:<code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#003454&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p><p><code>例子</code>:<code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#003454&gt;Hello World!&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p><p><code>效果</code>:</p><table><tr><td bgcolor=#FF32AB>Hello World!</td></tr></table><h3 id="3、设置文字对齐方式"><a href="#3、设置文字对齐方式" class="headerlink" title="3、设置文字对齐方式"></a><strong>3、设置文字对齐方式</strong></h3><p>在Markdown中设置文字对齐方式通过下列语法：</p><p><code>居中对齐</code>:<code>&lt;center&gt;内容&lt;/center&gt;</code></p><p><code>左对齐:</code> <code>&lt;p align=&quot;left&quot;&gt;内容&lt;/p&gt;</code></p><p><code>右对齐</code>:<code>&lt;p align=&quot;right&quot;&gt;内容&lt;/p&gt;举例效果：</code>:</p><p align="left">富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善</p><center>富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善</center><p align="right">富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善</p><h3 id="4、加上下标"><a href="#4、加上下标" class="headerlink" title="4、加上下标"></a><strong>4、加上下标</strong></h3><p><code>下标语法</code>：<code>内容&lt;sub&gt;内容&lt;/sub&gt;内容</code><br><code>例子</code>: <code>Na&lt;sub&gt;2CO&lt;sub&gt;3</code><br><code>效果</code>:Na<sub>2</sub>CO<sub>3</sub><br><code>上标语法</code>:<code>内容&lt;sup&gt;内容&lt;/sup&gt;内容</code><br><code>例子</code>：<code>深圳腾讯&lt;sup&gt;TM&lt;/sup&gt;</code><br><code>效果</code>:深圳腾讯<sup>TM</sup></p><h2 id="三、Markdown进阶使用"><a href="#三、Markdown进阶使用" class="headerlink" title="三、Markdown进阶使用"></a>三、Markdown进阶使用</h2><h3 id="1、超链接"><a href="#1、超链接" class="headerlink" title="1、超链接"></a><strong>1、超链接</strong></h3><p>Markdown支持两种形式的链接语法：行内式和参考式。</p><ul><li><strong>行式链接</strong></li></ul><p><code>行内式语法</code>:<code>内容[链接名](链接地址）内容</code><br><code>例子</code>：这就是<a href="http://baidu.com">百度</a>,点击一下，你就知道！<br>当然如果想在新标签也中打开链接网址，学过html的都知道，可以用<code>&lt;a href=&quot;链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</code><br>例如：<code>&lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt;</code><br><code>效果</code>：<a href="http://baidu.com" target="_blank">百度一下</a></p><ul><li><strong>参考式链接</strong><br><code>参考式链接语法</code>：<code>内容[链接名][id]内容</code>+<code>[id]:链接地址</code>,后者可以写在文章的任意位置，当然一般写在底部。<br><code>例子</code>:<code>内容可参考[百度一下][1].[1]:www.baidu.com</code><br><code>效果</code>:内容可参考<a href="http://baidu.com/">百度</a></li></ul><h3 id="2、自动链接"><a href="#2、自动链接" class="headerlink" title="2、自动链接"></a><strong>2、自动链接</strong></h3><p>Markdown也可以自动链接的形式来处理网址和电子邮件信箱，只需要用尖括号括起来就可以了，Markdown会将其自动转换成链接。<br><code>例子</code>:<code>&lt;http://baidu.com&gt;</code><br><code>效果</code>:<a href="http://baidu.com">http://baidu.com</a></p><h3 id="3、图片的使用"><a href="#3、图片的使用" class="headerlink" title="3、图片的使用"></a><strong>3、图片的使用</strong></h3><p>在日常的博客编写的过程中少不了图片的使用。Markdown中的图片插入不同于word直接拖拽式的，而是通过特定的语法来引用。与超链接相同，图片的插入同样分为<code>行内式</code>和<code>参考式</code>两种。</p><ul><li><p><strong>行内式</strong><br><code>语法</code>:<code>![自定义内容](URL)</code><br><code>例子</code>:<code>![行情分析](https://myblog-picture-1259758352.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20200731192642.png)</code><br><code>效果</code>:<img src="https://myblog-picture-1259758352.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20200731192642.png" alt="行情分析"><br><code>注意</code>:上面的<code>URL</code>可以为本地路径，也可以是图片的网址。当然显然第二种更好，因为这样当本地路径发生变化时图片并不会丢失。这里我选择的是<code>腾讯云图床</code>对博客中的图片进行存储。</p></li><li><p><strong>参考式</strong><br>参考式的用法与超链接大同小异，不在赘述！</p></li><li><strong>图片的对齐方式</strong><br><code>语法</code>:<code>&lt;div align=center&gt;![自定义内容](URL)</code>,想要居右对齐，修改<code>align</code>参数为<code>right</code>即可。与上述的文字的对齐方式大同小异，不再演示。</li><li><strong>图片大小的设置</strong><br><code>语法</code>：<code>&lt;img src=&quot;URL&quot; width=&quot;数值或者百分比&quot; height=&quot;数值或百分比&quot;/&gt;</code><br><code>例子</code>:<code>&lt;img src=&quot;https://myblog-picture-1259758352.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20200731192642.png&quot; width=&quot;200&quot; height=&quot;100&quot; div align=center/&gt;</code><br><code>效果</code>:<br><img src="https://myblog-picture-1259758352.cos.ap-nanjing.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20200731192642.png" width="400" height="300" div align=center/></li></ul><h3 id="4、LaTeX公式"><a href="#4、LaTeX公式" class="headerlink" title="4、LaTeX公式"></a><strong>4、LaTeX公式</strong></h3><p>由于本人可能近期用到LaTeX公式的情况比较少，所以仅举一个原作者中提到的一个例子。<br><code>例子</code>:<script type="math/tex">X\stackrel{F}{\longrightarrow}Y</script><br><code>效果</code>:$ X\stackrel{F}{\longrightarrow}Y$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上列举的是最为常用的Markdown用法，当然Markdown还有许多其他的用法，感兴趣的可以查阅相关资料。</p><hr><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/99319314">Markdown语法及原理从入门到高级(可能是全网最全）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>